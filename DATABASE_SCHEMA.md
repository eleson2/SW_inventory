# Database Schema Design\n\nThis document outlines the recommended database schema for the SW Inventory system. The schema is designed to be database-agnostic but examples use SQL-like syntax.\n\n## Entity Relationship Diagram (Text)\n\n```\nCustomer (1) ---- (M) LPAR\nVendor (1) ---- (M) Software\nPackage (1) ---- (M) PackageItem ---- (1) Software\nLPAR (M) ---- (M) LparSoftware ---- (1) Software\nLPAR (1) ---- (1) Package [current]\n```\n\n## Tables\n\n### customers\n\nStores basic customer information in multi-tenant environment.\n\n```sql\nCREATE TABLE customers (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  name VARCHAR(100) NOT NULL,\n  code VARCHAR(20) NOT NULL UNIQUE,\n  description TEXT,\n  active BOOLEAN NOT NULL DEFAULT true,\n  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n\n  CONSTRAINT chk_code_format CHECK (code ~ '^[A-Z0-9_-]+$')\n);\n\nCREATE INDEX idx_customers_active ON customers(active);\nCREATE INDEX idx_customers_code ON customers(code);\n```\n\n### vendors\n\nStores software vendor information and contact details.\n\n```sql\nCREATE TABLE vendors (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  name VARCHAR(100) NOT NULL,\n  code VARCHAR(20) NOT NULL UNIQUE,\n  website VARCHAR(255),\n  contact_email VARCHAR(255),\n  active BOOLEAN NOT NULL DEFAULT true,\n  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n\n  CONSTRAINT chk_code_format CHECK (code ~ '^[A-Z0-9_-]+$'),\n  CONSTRAINT chk_email_format CHECK (contact_email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$')\n);\n\nCREATE INDEX idx_vendors_active ON vendors(active);\nCREATE INDEX idx_vendors_code ON vendors(code);\n```\n\n### software\n\nStores software products with version information.\n\n```sql\nCREATE TABLE software (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  name VARCHAR(100) NOT NULL,\n  vendor_id UUID NOT NULL REFERENCES vendors(id) ON DELETE RESTRICT,\n  description TEXT,\n  current_version VARCHAR(50) NOT NULL,\n  current_ptf_level VARCHAR(50),\n  version_history JSONB NOT NULL DEFAULT '[]',\n  active BOOLEAN NOT NULL DEFAULT true,\n  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE INDEX idx_software_vendor ON software(vendor_id);\nCREATE INDEX idx_software_active ON software(active);\nCREATE INDEX idx_software_name ON software(name);\n```\n\n**version_history structure:**\n```json\n[\n  {\n    "version": "V2R3M0",\n    "ptfLevel": "PTF11111",\n    "releasedAt": "2023-12-01T00:00:00Z"\n  }\n]\n```\n\n### packages\n\nStores software package definitions (sets of tested software versions).\n\n```sql\nCREATE TABLE packages (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  name VARCHAR(100) NOT NULL,\n  code VARCHAR(20) NOT NULL UNIQUE,\n  description TEXT,\n  version VARCHAR(50) NOT NULL,\n  release_date DATE NOT NULL,\n  active BOOLEAN NOT NULL DEFAULT true,\n  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n\n  CONSTRAINT chk_code_format CHECK (code ~ '^[A-Z0-9_-]+$')\n);\n\nCREATE INDEX idx_packages_active ON packages(active);\nCREATE INDEX idx_packages_release_date ON packages(release_date DESC);\nCREATE INDEX idx_packages_code ON packages(code);\nCREATE UNIQUE INDEX idx_packages_code_version ON packages(code, version);\n```\n\n### package_items\n\nJunction table linking packages to specific software versions.\n\n```sql\nCREATE TABLE package_items (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  package_id UUID NOT NULL REFERENCES packages(id) ON DELETE CASCADE,\n  software_id UUID NOT NULL REFERENCES software(id) ON DELETE RESTRICT,\n  version VARCHAR(50) NOT NULL,\n  ptf_level VARCHAR(50),\n  required BOOLEAN NOT NULL DEFAULT true,\n  order_index INTEGER NOT NULL,\n  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n\n  CONSTRAINT uq_package_software UNIQUE (package_id, software_id)\n);\n\nCREATE INDEX idx_package_items_package ON package_items(package_id);\nCREATE INDEX idx_package_items_software ON package_items(software_id);\nCREATE INDEX idx_package_items_order ON package_items(package_id, order_index);\n```\n\n### lpars\n\nStores LPAR (Logical Partition) configurations.\n\n```sql\nCREATE TABLE lpars (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  name VARCHAR(100) NOT NULL,\n  code VARCHAR(20) NOT NULL UNIQUE,\n  customer_id UUID NOT NULL REFERENCES customers(id) ON DELETE RESTRICT,\n  description TEXT,\n  current_package_id UUID REFERENCES packages(id) ON DELETE SET NULL,\n  active BOOLEAN NOT NULL DEFAULT true,\n  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n\n  CONSTRAINT chk_code_format CHECK (code ~ '^[A-Z0-9_-]+$')\n);\n\nCREATE INDEX idx_lpars_customer ON lpars(customer_id);\nCREATE INDEX idx_lpars_package ON lpars(current_package_id);\nCREATE INDEX idx_lpars_active ON lpars(active);\nCREATE INDEX idx_lpars_code ON lpars(code);\n```\n\n### lpar_software\n\nJunction table tracking software installed on each LPAR with version history.\n\n```sql\nCREATE TABLE lpar_software (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  lpar_id UUID NOT NULL REFERENCES lpars(id) ON DELETE CASCADE,\n  software_id UUID NOT NULL REFERENCES software(id) ON DELETE RESTRICT,\n  current_version VARCHAR(50) NOT NULL,\n  current_ptf_level VARCHAR(50),\n  previous_version VARCHAR(50),\n  previous_ptf_level VARCHAR(50),\n  installed_date TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  rolled_back BOOLEAN NOT NULL DEFAULT false,\n\n  CONSTRAINT uq_lpar_software UNIQUE (lpar_id, software_id)\n);\n\nCREATE INDEX idx_lpar_software_lpar ON lpar_software(lpar_id);\nCREATE INDEX idx_lpar_software_software ON lpar_software(software_id);\nCREATE INDEX idx_lpar_software_rolled_back ON lpar_software(lpar_id, rolled_back);\n```\n\n### audit_log\n\nTracks all changes for compliance and debugging.\n\n```sql\nCREATE TABLE audit_log (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  entity_type VARCHAR(50) NOT NULL,\n  entity_id UUID NOT NULL,\n  action VARCHAR(20) NOT NULL,\n  changes JSONB NOT NULL,\n  user_id UUID,\n  timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n\n  CONSTRAINT chk_entity_type CHECK (entity_type IN ('customer', 'vendor', 'software', 'package', 'lpar')),\n  CONSTRAINT chk_action CHECK (action IN ('create', 'update', 'delete', 'rollback'))\n);\n\nCREATE INDEX idx_audit_log_entity ON audit_log(entity_type, entity_id);\nCREATE INDEX idx_audit_log_timestamp ON audit_log(timestamp DESC);\nCREATE INDEX idx_audit_log_user ON audit_log(user_id);\n```\n\n**changes structure example:**\n```json\n{\n  "before": {\n    "version": "V2R3M0",\n    "ptfLevel": "PTF11111"\n  },\n  "after": {\n    "version": "V2R4M0",\n    "ptfLevel": "PTF12345"\n  }\n}\n```\n\n## Prisma Schema Example\n\nIf using Prisma ORM, here's the equivalent schema:\n\n```prisma\n// schema.prisma\ngenerator client {\n  provider = "prisma-client-js"\n}\n\ndatasource db {\n  provider = "postgresql"\n  url      = env("DATABASE_URL")\n}\n\nmodel Customer {\n  id          String   @id @default(uuid())\n  name        String   @db.VarChar(100)\n  code        String   @unique @db.VarChar(20)\n  description String?\n  active      Boolean  @default(true)\n  createdAt   DateTime @default(now()) @map("created_at")\n  updatedAt   DateTime @updatedAt @map("updated_at")\n\n  lpars Lpar[]\n\n  @@index([active])\n  @@index([code])\n  @@map("customers")\n}\n\nmodel Vendor {\n  id           String   @id @default(uuid())\n  name         String   @db.VarChar(100)\n  code         String   @unique @db.VarChar(20)\n  website      String?  @db.VarChar(255)\n  contactEmail String?  @map("contact_email") @db.VarChar(255)\n  active       Boolean  @default(true)\n  createdAt    DateTime @default(now()) @map("created_at")\n  updatedAt    DateTime @updatedAt @map("updated_at")\n\n  software Software[]\n\n  @@index([active])\n  @@index([code])\n  @@map("vendors")\n}\n\nmodel Software {\n  id              String   @id @default(uuid())\n  name            String   @db.VarChar(100)\n  vendorId        String   @map("vendor_id")\n  description     String?\n  currentVersion  String   @map("current_version") @db.VarChar(50)\n  currentPtfLevel String?  @map("current_ptf_level") @db.VarChar(50)\n  versionHistory  Json     @default("[]") @map("version_history")\n  active          Boolean  @default(true)\n  createdAt       DateTime @default(now()) @map("created_at")\n  updatedAt       DateTime @updatedAt @map("updated_at")\n\n  vendor        Vendor          @relation(fields: [vendorId], references: [id], onDelete: Restrict)\n  packageItems  PackageItem[]\n  lparSoftware  LparSoftware[]\n\n  @@index([vendorId])\n  @@index([active])\n  @@index([name])\n  @@map("software")\n}\n\nmodel Package {\n  id          String   @id @default(uuid())\n  name        String   @db.VarChar(100)\n  code        String   @unique @db.VarChar(20)\n  description String?\n  version     String   @db.VarChar(50)\n  releaseDate DateTime @map("release_date") @db.Date\n  active      Boolean  @default(true)\n  createdAt   DateTime @default(now()) @map("created_at")\n  updatedAt   DateTime @updatedAt @map("updated_at")\n\n  items PackageItem[]\n  lpars Lpar[]\n\n  @@unique([code, version])\n  @@index([active])\n  @@index([releaseDate(sort: Desc)])\n  @@index([code])\n  @@map("packages")\n}\n\nmodel PackageItem {\n  id         String   @id @default(uuid())\n  packageId  String   @map("package_id")\n  softwareId String   @map("software_id")\n  version    String   @db.VarChar(50)\n  ptfLevel   String?  @map("ptf_level") @db.VarChar(50)\n  required   Boolean  @default(true)\n  orderIndex Int      @map("order_index")\n  createdAt  DateTime @default(now()) @map("created_at")\n\n  package  Package  @relation(fields: [packageId], references: [id], onDelete: Cascade)\n  software Software @relation(fields: [softwareId], references: [id], onDelete: Restrict)\n\n  @@unique([packageId, softwareId])\n  @@index([packageId])\n  @@index([softwareId])\n  @@index([packageId, orderIndex])\n  @@map("package_items")\n}\n\nmodel Lpar {\n  id               String   @id @default(uuid())\n  name             String   @db.VarChar(100)\n  code             String   @unique @db.VarChar(20)\n  customerId       String   @map("customer_id")\n  description      String?\n  currentPackageId String?  @map("current_package_id")\n  active           Boolean  @default(true)\n  createdAt        DateTime @default(now()) @map("created_at")\n  updatedAt        DateTime @updatedAt @map("updated_at")\n\n  customer        Customer       @relation(fields: [customerId], references: [id], onDelete: Restrict)\n  currentPackage  Package?       @relation(fields: [currentPackageId], references: [id], onDelete: SetNull)\n  softwareInstalled LparSoftware[]\n\n  @@index([customerId])\n  @@index([currentPackageId])\n  @@index([active])\n  @@index([code])\n  @@map("lpars")\n}\n\nmodel LparSoftware {\n  id               String   @id @default(uuid())\n  lparId           String   @map("lpar_id")\n  softwareId       String   @map("software_id")\n  currentVersion   String   @map("current_version") @db.VarChar(50)\n  currentPtfLevel  String?  @map("current_ptf_level") @db.VarChar(50)\n  previousVersion  String?  @map("previous_version") @db.VarChar(50)\n  previousPtfLevel String?  @map("previous_ptf_level") @db.VarChar(50)\n  installedDate    DateTime @default(now()) @map("installed_date")\n  rolledBack       Boolean  @default(false) @map("rolled_back")\n\n  lpar     Lpar     @relation(fields: [lparId], references: [id], onDelete: Cascade)\n  software Software @relation(fields: [softwareId], references: [id], onDelete: Restrict)\n\n  @@unique([lparId, softwareId])\n  @@index([lparId])\n  @@index([softwareId])\n  @@index([lparId, rolledBack])\n  @@map("lpar_software")\n}\n\nmodel AuditLog {\n  id         String   @id @default(uuid())\n  entityType String   @map("entity_type") @db.VarChar(50)\n  entityId   String   @map("entity_id")\n  action     String   @db.VarChar(20)\n  changes    Json\n  userId     String?  @map("user_id")\n  timestamp  DateTime @default(now())\n\n  @@index([entityType, entityId])\n  @@index([timestamp(sort: Desc)])\n  @@index([userId])\n  @@map("audit_log")\n}\n```\n\n## Queries for Common Operations\n\n### Get LPAR with all installed software\n\n```sql\nSELECT\n  l.*,\n  c.name as customer_name,\n  p.name as package_name,\n  p.version as package_version,\n  json_agg(\n    json_build_object(\n      'software_id', ls.software_id,\n      'software_name', s.name,\n      'version', ls.current_version,\n      'ptf_level', ls.current_ptf_level,\n      'installed_date', ls.installed_date,\n      'rolled_back', ls.rolled_back\n    )\n  ) as software_installed\nFROM lpars l\nLEFT JOIN customers c ON l.customer_id = c.id\nLEFT JOIN packages p ON l.current_package_id = p.id\nLEFT JOIN lpar_software ls ON l.id = ls.lpar_id\nLEFT JOIN software s ON ls.software_id = s.id\nWHERE l.id = $1\nGROUP BY l.id, c.name, p.name, p.version;\n```\n\n### Get package with all items\n\n```sql\nSELECT\n  p.*,\n  json_agg(\n    json_build_object(\n      'software_id', pi.software_id,\n      'software_name', s.name,\n      'version', pi.version,\n      'ptf_level', pi.ptf_level,\n      'required', pi.required,\n      'order', pi.order_index\n    ) ORDER BY pi.order_index\n  ) as items\nFROM packages p\nLEFT JOIN package_items pi ON p.id = pi.package_id\nLEFT JOIN software s ON pi.software_id = s.id\nWHERE p.id = $1\nGROUP BY p.id;\n```\n\n### Find LPARs with outdated software\n\n```sql\nSELECT\n  l.id,\n  l.name,\n  l.code,\n  s.name as software_name,\n  ls.current_version as installed_version,\n  s.current_version as latest_version\nFROM lpars l\nJOIN lpar_software ls ON l.id = ls.lpar_id\nJOIN software s ON ls.software_id = s.id\nWHERE ls.current_version != s.current_version\n  AND l.active = true\n  AND s.active = true;\n```\n\n## Indexes for Performance\n\nKey indexes have been defined above, but additional composite indexes may be needed based on query patterns:\n\n```sql\n-- For filtering LPARs by customer and package\nCREATE INDEX idx_lpars_customer_package ON lpars(customer_id, current_package_id)\nWHERE active = true;\n\n-- For finding software by vendor and status\nCREATE INDEX idx_software_vendor_active ON software(vendor_id, active);\n\n-- For audit log queries by entity and date range\nCREATE INDEX idx_audit_log_entity_timestamp ON audit_log(entity_type, entity_id, timestamp DESC);\n```\n\n## Data Integrity Rules\n\n1. **Cascading Deletes**: When a package is deleted, all its items are deleted (CASCADE)\n2. **Restricted Deletes**: Cannot delete a vendor/customer/software that is referenced by other entities (RESTRICT)\n3. **Soft Deletes**: Use `active` flag instead of hard deletes for most entities\n4. **Version History**: Store complete version history in JSONB for audit trail\n5. **Unique Constraints**: Enforce code uniqueness and prevent duplicate software on same LPAR\n