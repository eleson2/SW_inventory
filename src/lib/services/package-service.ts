/**\n * Service for managing software packages and LPAR deployments\n */\nimport type { Package, PackageItem, Lpar, LparSoftware, SoftwareVersion } from '$types';\nimport { compareSoftwareVersions, isVersionCompatible } from '$utils/version-parser';\n\n/**\n * Get the subset of package items relevant for a specific customer's LPAR\n * A customer only receives the software that are relevant for them\n */\nexport function getCustomerPackageSubset(\n	fullPackage: Package,\n	customerRequirements: string[]\n): PackageItem[] {\n	if (!fullPackage.items) return [];\n	return fullPackage.items.filter(item =>\n		customerRequirements.includes(item.software_id)\n	);\n}\n\n/**\n * Check if an LPAR has all required software from its assigned package\n */\nexport function validateLparPackageCompliance(\n	lpar: Lpar,\n	fullPackage: Package\n): {\n	compliant: boolean;\n	missingSoftware: PackageItem[];\n	outdatedSoftware: Array<{ item: PackageItem; installed: SoftwareVersion }>;\n} {\n	const missingSoftware: PackageItem[] = [];\n	const outdatedSoftware: Array<{ item: PackageItem; installed: SoftwareVersion }> = [];\n\n	if (!fullPackage.items || !lpar.lpar_software) return {\n		compliant: true,\n		missingSoftware,\n		outdatedSoftware\n	};\n\n	for (const packageItem of fullPackage.items) {\n		const installed = lpar.lpar_software.find(\n			(s) => s.software_id === packageItem.software_id\n		);\n\n		if (!installed) {\n			if (packageItem.required) {\n				missingSoftware.push(packageItem);\n			}\n		} else {\n			// Check if version is compatible - using current_version from lpar_software\n			const installedVersion = {\n				version: installed.current_version,\n				ptfLevel: installed.current_ptf_level || undefined\n			};\n			// Note: packageItem should have software_version relation loaded for comparison\n			// For now, skip version comparison as structure changed\n			// TODO: Update this to use software_version_id comparison\n		}\n	}\n\n	return {\n		compliant: missingSoftware.length === 0 && outdatedSoftware.length === 0,\n		missingSoftware,\n		outdatedSoftware\n	};\n}\n\n/**\n * Generate a deployment plan for upgrading an LPAR to a new package\n */\nexport function generateDeploymentPlan(\n	lpar: Lpar,\n	targetPackage: Package,\n	customerRequirements: string[]\n): {\n	toInstall: PackageItem[];\n	toUpgrade: Array<{ item: PackageItem; currentVersion: SoftwareVersion }>;\n	toRemove: LparSoftware[];\n	noChange: LparSoftware[];\n} {\n	const relevantPackageItems = getCustomerPackageSubset(targetPackage, customerRequirements);\n	const toInstall: PackageItem[] = [];\n	const toUpgrade: Array<{ item: PackageItem; currentVersion: SoftwareVersion }> = [];\n	const toRemove: LparSoftware[] = [];\n	const noChange: LparSoftware[] = [];\n\n	if (!lpar.lpar_software) return {\n		toInstall: relevantPackageItems,\n		toUpgrade,\n		toRemove,\n		noChange\n	};\n\n	// Check each package item\n	for (const packageItem of relevantPackageItems) {\n		const installed = lpar.lpar_software.find(\n			(s) => s.software_id === packageItem.software_id\n		);\n\n		if (!installed) {\n			toInstall.push(packageItem);\n		} else {\n			// Compare versions using software_version_id\n			// For now, mark as no change if already installed\n			// TODO: Implement proper version comparison using software_version_id\n			noChange.push(installed);\n		}\n	}\n\n	// Check for software to remove (not in new package)\n	const packageSoftwareIds = new Set(relevantPackageItems.map(i => i.software_id));\n	for (const installed of lpar.lpar_software) {\n		if (!packageSoftwareIds.has(installed.software_id)) {\n			toRemove.push(installed);\n		}\n	}\n\n	return {\n		toInstall,\n		toUpgrade,\n		toRemove,\n		noChange\n	};\n}\n\n/**\n * Rollback a specific software to its previous version\n */\nexport function rollbackSoftware(\n	lpar: Lpar,\n	softwareId: string\n): LparSoftware | null {\n	if (!lpar.lpar_software) return null;\n\n	const installed = lpar.lpar_software.find((s) => s.software_id === softwareId);\n\n	if (!installed || !installed.previous_version) {\n		return null;\n	}\n\n	return {\n		...installed,\n		current_version: installed.previous_version,\n		current_ptf_level: installed.previous_ptf_level,\n		previous_version: installed.current_version,\n		previous_ptf_level: installed.current_ptf_level,\n		rolled_back: true,\n		installed_date: new Date()\n	};\n}\n\n/**\n * Calculate compatibility score between LPAR and package\n * Returns a percentage of how compatible the LPAR's current software is with the package\n */\nexport function calculateCompatibilityScore(\n	lpar: Lpar,\n	targetPackage: Package\n): number {\n	if (!targetPackage.items || targetPackage.items.length === 0) return 100;\n	if (!lpar.lpar_software) return 0;\n\n	let compatibleCount = 0;\n\n	for (const packageItem of targetPackage.items) {\n		const installed = lpar.lpar_software.find(\n			(s) => s.software_id === packageItem.software_id\n		);\n\n		if (installed) {\n			// For now, count as compatible if installed\n			// TODO: Implement proper version comparison using software_version_id\n			compatibleCount++;\n		}\n	}\n\n	return Math.round((compatibleCount / targetPackage.items.length) * 100);\n}\n