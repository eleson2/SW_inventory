/**\n * Cloning utilities for Products, Packages, and LPARs\n * Provides functions to duplicate entities with all their relationships\n */\nimport { db, createAuditLog } from './db';\n\n/**\n * Clone a software product\n * Creates a new software with all metadata from the source\n */\nexport async function cloneSoftware(\n	sourceId: string,\n	newName: string,\n	userId?: string\n) {\n	const source = await db.software.findUnique({\n		where: { id: sourceId },\n		include: { vendors: true }\n	});\n\n	if (!source) {\n		throw new Error('Source software not found');\n	}\n\n	const cloned = await db.software.create({\n		data: {\n			name: newName,\n			vendor_id: source.vendor_id,\n			description: `Cloned from: ${source.name}\n\n${source.description || ''}`.trim(),\n			current_version_id: source.current_version_id,\n			active: source.active\n		}\n	});\n\n	// Create audit log\n	await createAuditLog('software', cloned.id, 'create', {\n		action: 'clone',\n		sourceId,\n		sourceName: source.name,\n		newName,\n		...cloned\n	}, userId);\n\n	return cloned;\n}\n\n/**\n * Clone a package with all its items\n * Creates a new package version with all software dependencies\n */\nexport async function clonePackage(\n	sourceId: string,\n	newName: string,\n	newCode: string,\n	newVersion: string,\n	userId?: string\n) {\n	const source = await db.packages.findUnique({\n		where: { id: sourceId },\n		include: {\n			package_items: {\n				include: { software: true },\n				orderBy: { order_index: 'asc' }\n			}\n		}\n	});\n\n	if (!source) {\n		throw new Error('Source package not found');\n	}\n\n	// Check if code already exists\n	const existing = await db.packages.findFirst({\n		where: {\n			code: newCode,\n			version: newVersion\n		}\n	});\n\n	if (existing) {\n		throw new Error('Package with this code and version already exists');\n	}\n\n	// Create cloned package with items in a transaction\n	const cloned = await db.$transaction(async (tx) => {\n		const newPackage = await tx.packages.create({\n			data: {\n				name: newName,\n				code: newCode,\n				version: newVersion,\n				description: `Cloned from: ${source.name} (${source.code} ${source.version})\n\n${source.description || ''}`.trim(),\n				release_date: new Date(),\n				active: source.active\n			}\n		});\n\n		// Clone all package items\n		for (const item of source.package_items) {\n			await tx.package_items.create({\n				data: {\n					package_id: newPackage.id,\n					software_id: item.software_id,\n					software_version_id: item.software_version_id,\n					required: item.required,\n					order_index: item.order_index\n				}\n			});\n		}\n\n		return newPackage;\n	});\n\n	// Create audit log\n	await createAuditLog('package', cloned.id, 'create', {\n		action: 'clone',\n		sourceId,\n		sourceName: source.name,\n		sourceCode: source.code,\n		sourceVersion: source.version,\n		newName,\n		newCode,\n		newVersion,\n		itemsCloned: source.package_items.length\n	}, userId);\n\n	return cloned;\n}\n\n/**\n * Clone an LPAR with all installed software\n * Optionally assign to a different customer\n */\nexport async function cloneLpar(\n	sourceId: string,\n	newName: string,\n	newCode: string,\n	customerId?: string,\n	userId?: string\n) {\n	const source = await db.lpars.findUnique({\n		where: { id: sourceId },\n		include: {\n			customers: true,\n			packages: true,\n			lpar_software: {\n				include: { software: true }\n			}\n		}\n	});\n\n	if (!source) {\n		throw new Error('Source LPAR not found');\n	}\n\n	// Use provided customer or source customer\n	const targetCustomerId = customerId || source.customer_id;\n\n	// Check if code already exists\n	const existing = await db.lpars.findUnique({\n		where: { code: newCode }\n	});\n\n	if (existing) {\n		throw new Error('LPAR with this code already exists');\n	}\n\n	// Create cloned LPAR with software in a transaction\n	const cloned = await db.$transaction(async (tx) => {\n		const newLpar = await tx.lpars.create({\n			data: {\n				name: newName,\n				code: newCode,\n				customer_id: targetCustomerId,\n				description: `Cloned from: ${source.name} (${source.code})\n\n${source.description || ''}`.trim(),\n				current_package_id: source.current_package_id,\n				active: source.active\n			}\n		});\n\n		// Clone all installed software\n		for (const sw of source.lpar_software) {\n			await tx.lpar_software.create({\n				data: {\n					lpar_id: newLpar.id,\n					software_id: sw.software_id,\n					current_version: sw.current_version,\n					current_ptf_level: sw.current_ptf_level,\n					previous_version: sw.previous_version,\n					previous_ptf_level: sw.previous_ptf_level,\n					installed_date: new Date(),\n					rolled_back: false // Reset rollback status for cloned LPAR\n				}\n			});\n		}\n\n		return newLpar;\n	});\n\n	// Create audit log\n	await createAuditLog('lpar', cloned.id, 'create', {\n		action: 'clone',\n		sourceId,\n		sourceName: source.name,\n		sourceCode: source.code,\n		newName,\n		newCode,\n		customerId: targetCustomerId,\n		softwareCloned: source.lpar_software.length\n	}, userId);\n\n	return cloned;\n}\n\n/**\n * Clone a customer\n * Creates a new customer with metadata from the source\n */\nexport async function cloneCustomer(\n	sourceId: string,\n	newName: string,\n	newCode: string,\n	userId?: string\n) {\n	const source = await db.customers.findUnique({\n		where: { id: sourceId },\n		include: {\n			lpars: true\n		}\n	});\n\n	if (!source) {\n		throw new Error('Source customer not found');\n	}\n\n	// Check if code already exists\n	const existing = await db.customers.findUnique({\n		where: { code: newCode }\n	});\n\n	if (existing) {\n		throw new Error('Customer with this code already exists');\n	}\n\n	const cloned = await db.customers.create({\n		data: {\n			name: newName,\n			code: newCode,\n			description: `Cloned from: ${source.name} (${source.code})\n\n${source.description || ''}`.trim(),\n			active: source.active\n		}\n	});\n\n	// Create audit log\n	await createAuditLog('customer', cloned.id, 'create', {\n		action: 'clone',\n		sourceId,\n		sourceName: source.name,\n		sourceCode: source.code,\n		newName,\n		newCode\n	}, userId);\n\n	return cloned;\n}\n\n/**\n * Clone a vendor\n * Creates a new vendor with metadata from the source\n */\nexport async function cloneVendor(\n	sourceId: string,\n	newName: string,\n	newCode: string,\n	userId?: string\n) {\n	const source = await db.vendors.findUnique({\n		where: { id: sourceId },\n		include: {\n			software: true\n		}\n	});\n\n	if (!source) {\n		throw new Error('Source vendor not found');\n	}\n\n	// Check if code already exists\n	const existing = await db.vendors.findUnique({\n		where: { code: newCode }\n	});\n\n	if (existing) {\n		throw new Error('Vendor with this code already exists');\n	}\n\n	const cloned = await db.vendors.create({\n		data: {\n			name: newName,\n			code: newCode,\n			website: source.website,\n			contact_email: source.contact_email,\n			active: source.active\n		}\n	});\n\n	// Create audit log\n	await createAuditLog('vendor', cloned.id, 'create', {\n		action: 'clone',\n		sourceId,\n		sourceName: source.name,\n		sourceCode: source.code,\n		newName,\n		newCode\n	}, userId);\n\n	return cloned;\n}\n\n/**\n * Get clone preview - shows what will be cloned\n */\nexport async function getClonePreview(entityType: 'software' | 'package' | 'lpar' | 'customer' | 'vendor', sourceId: string) {\n	switch (entityType) {\n		case 'software': {\n			const software = await db.software.findUnique({\n				where: { id: sourceId },\n				include: { vendors: true }\n			});\n			return {\n				name: software?.name,\n				vendor: software?.vendors?.name,\n				currentVersionId: software?.current_version_id\n			};\n		}\n		case 'package': {\n			const pkg = await db.packages.findUnique({\n				where: { id: sourceId },\n				include: { package_items: true }\n			});\n			return {\n				name: pkg?.name,\n				code: pkg?.code,\n				version: pkg?.version,\n				itemCount: pkg?.package_items.length || 0,\n				releaseDate: pkg?.release_date\n			};\n		}\n		case 'lpar': {\n			const lpar = await db.lpars.findUnique({\n				where: { id: sourceId },\n				include: {\n					customers: true,\n					packages: true,\n					lpar_software: true\n				}\n			});\n			return {\n				name: lpar?.name,\n				code: lpar?.code,\n				customer: lpar?.customers?.name,\n				package: lpar?.packages?.name,\n				softwareCount: lpar?.lpar_software.length || 0\n			};\n		}\n		case 'customer': {\n			const customer = await db.customers.findUnique({\n				where: { id: sourceId },\n				include: { lpars: true }\n			});\n			return {\n				name: customer?.name,\n				code: customer?.code,\n				lparCount: customer?.lpars?.length || 0,\n				active: customer?.active\n			};\n		}\n		case 'vendor': {\n			const vendor = await db.vendors.findUnique({\n				where: { id: sourceId },\n				include: { software: true }\n			});\n			return {\n				name: vendor?.name,\n				code: vendor?.code,\n				website: vendor?.website,\n				softwareCount: vendor?.software?.length || 0,\n				active: vendor?.active\n			};\n		}\n	}\n}\n