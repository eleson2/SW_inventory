# Usage Examples\n\nThis document provides examples of how to use the key features of the SW Inventory system.\n\n## Version Parsing\n\n### Parse Vendor Designations\n\n```typescript\nimport { parseVendorDesignation } from '$utils/version-parser';\n\n// Parse different vendor formats\nconst v1 = parseVendorDesignation('V2R4M0-PTF12345');\n// Result: { version: 'V2R4M0', ptfLevel: 'PTF12345' }\n\nconst v2 = parseVendorDesignation('2.4.0 (PTF 12345)');\n// Result: { version: '2.4.0', ptfLevel: 'PTF 12345' }\n\nconst v3 = parseVendorDesignation('14.5');\n// Result: { version: '14.5', ptfLevel: undefined }\n```\n\n### Compare Versions\n\n```typescript\nimport { compareSoftwareVersions } from '$utils/version-parser';\n\nconst version1 = { version: 'V2R4M0', ptfLevel: 'PTF12345' };\nconst version2 = { version: 'V2R5M0', ptfLevel: 'PTF12346' };\n\nconst result = compareSoftwareVersions(version1, version2);\n// Result: -1 (version1 is older than version2)\n```\n\n### Check Version Compatibility\n\n```typescript\nimport { isVersionCompatible } from '$utils/version-parser';\n\nconst installed = { version: 'V2R5M0', ptfLevel: 'PTF12346' };\nconst required = { version: 'V2R4M0', ptfLevel: 'PTF12345' };\n\n// Lenient mode: installed >= required\nconst compatible = isVersionCompatible(installed, required);\n// Result: true\n\n// Strict mode: exact match\nconst exactMatch = isVersionCompatible(installed, required, true);\n// Result: false\n```\n\n## Package Management\n\n### Get Customer Package Subset\n\n```typescript\nimport { getCustomerPackageSubset } from '$lib/services/package-service';\n\nconst fullPackage = {\n  id: '1',\n  name: 'Mainframe Suite Q1 2024',\n  items: [\n    { softwareId: 'sw1', version: { version: '1.0' }, required: true, order: 1 },\n    { softwareId: 'sw2', version: { version: '2.0' }, required: true, order: 2 },\n    { softwareId: 'sw3', version: { version: '3.0' }, required: false, order: 3 },\n  ],\n  // ... other fields\n};\n\n// Customer only needs sw1 and sw2\nconst customerRequirements = ['sw1', 'sw2'];\nconst subset = getCustomerPackageSubset(fullPackage, customerRequirements);\n// Result: Array with only sw1 and sw2 items\n```\n\n### Validate LPAR Package Compliance\n\n```typescript\nimport { validateLparPackageCompliance } from '$lib/services/package-service';\n\nconst lpar = {\n  id: '1',\n  name: 'Production LPAR',\n  currentPackageId: '1',\n  softwareInstalled: [\n    {\n      softwareId: 'sw1',\n      version: { version: 'V2R4M0', ptfLevel: 'PTF12345' },\n      installedDate: new Date(),\n      rolledBack: false\n    }\n  ],\n  // ... other fields\n};\n\nconst targetPackage = {\n  id: '1',\n  items: [\n    {\n      softwareId: 'sw1',\n      version: { version: 'V2R4M0', ptfLevel: 'PTF12345' },\n      required: true,\n      order: 1\n    },\n    {\n      softwareId: 'sw2',\n      version: { version: 'V2R5M0' },\n      required: true,\n      order: 2\n    }\n  ],\n  // ... other fields\n};\n\nconst validation = validateLparPackageCompliance(lpar, targetPackage);\n// Result: {\n//   compliant: false,\n//   missingSoftware: [sw2 item],\n//   outdatedSoftware: []\n// }\n```\n\n### Generate Deployment Plan\n\n```typescript\nimport { generateDeploymentPlan } from '$lib/services/package-service';\n\nconst deploymentPlan = generateDeploymentPlan(\n  lpar,\n  targetPackage,\n  ['sw1', 'sw2', 'sw3']\n);\n\n// Result: {\n//   toInstall: [list of PackageItems to install],\n//   toUpgrade: [list of items needing upgrade with current versions],\n//   toRemove: [list of LparSoftware to remove],\n//   noChange: [list of LparSoftware that match package]\n// }\n\nconsole.log(`Need to install: ${deploymentPlan.toInstall.length} items`);\nconsole.log(`Need to upgrade: ${deploymentPlan.toUpgrade.length} items`);\nconsole.log(`Need to remove: ${deploymentPlan.toRemove.length} items`);\n```\n\n### Calculate Compatibility Score\n\n```typescript\nimport { calculateCompatibilityScore } from '$lib/services/package-service';\n\nconst score = calculateCompatibilityScore(lpar, targetPackage);\n// Result: 0-100 percentage score indicating compatibility\nconsole.log(`LPAR is ${score}% compatible with the target package`);\n```\n\n### Rollback Software\n\n```typescript\nimport { rollbackSoftware } from '$lib/services/package-service';\n\nconst rolledBack = rollbackSoftware(lpar, 'sw1');\n\nif (rolledBack) {\n  console.log(`Rolled back to version: ${rolledBack.version.version}`);\n  // Update LPAR in database with new rollback state\n} else {\n  console.log('Cannot rollback: no previous version available');\n}\n```\n\n## Form Validation\n\n### Validate Customer Input\n\n```typescript\nimport { customerSchema } from '$schemas';\n\nconst formData = {\n  name: 'Acme Corp',\n  code: 'ACME-001',\n  description: 'Test customer',\n  active: true\n};\n\ntry {\n  const validated = customerSchema.parse(formData);\n  // validated is type-safe and cleaned\n  console.log('Valid customer data:', validated);\n} catch (error) {\n  if (error instanceof z.ZodError) {\n    console.log('Validation errors:', error.flatten().fieldErrors);\n  }\n}\n```\n\n### Server-Side Form Handling\n\n```typescript\n// In +page.server.ts\nimport { customerSchema } from '$schemas';\nimport { fail, redirect } from '@sveltejs/kit';\n\nexport const actions = {\n  default: async ({ request }) => {\n    const formData = await request.formData();\n    const data = Object.fromEntries(formData);\n\n    try {\n      const validated = customerSchema.parse(data);\n\n      // TODO: Save to database\n      // await db.customer.create({ data: validated });\n\n      throw redirect(303, '/customers');\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return fail(400, {\n          errors: error.flatten().fieldErrors,\n          message: 'Validation failed'\n        });\n      }\n      throw error;\n    }\n  }\n};\n```\n\n## DataTable Component\n\n### Basic Usage\n\n```svelte\n<script lang="ts">\n  import DataTable from '$components/common/DataTable.svelte';\n  import type { Customer } from '$types';\n\n  let customers: Customer[] = [/* ... */];\n\n  const columns = [\n    { key: 'code', label: 'Code', sortable: true },\n    { key: 'name', label: 'Name', sortable: true },\n    {\n      key: 'active',\n      label: 'Status',\n      render: (customer: Customer) => {\n        return StatusBadge({ active: customer.active });\n      }\n    }\n  ];\n\n  function handleRowClick(customer: Customer) {\n    goto(`/customers/${customer.id}`);\n  }\n\n  function handleSort(field: string) {\n    // Implement sorting logic\n  }\n</script>\n\n<DataTable\n  data={customers}\n  {columns}\n  onRowClick={handleRowClick}\n  onSort={handleSort}\n/>\n```\n\n## Component Composition\n\n### Creating a Consistent Form\n\n```svelte\n<script lang="ts">\n  import FormField from '$components/common/FormField.svelte';\n  import Button from '$components/ui/Button.svelte';\n  import Card from '$components/ui/Card.svelte';\n\n  let formData = $state({\n    name: '',\n    code: '',\n    email: ''\n  });\n</script>\n\n<Card class="p-6">\n  <form method="POST" class="space-y-6">\n    <FormField\n      label="Name"\n      id="name"\n      name="name"\n      bind:value={formData.name}\n      required\n      placeholder="Enter name"\n    />\n\n    <FormField\n      label="Code"\n      id="code"\n      name="code"\n      bind:value={formData.code}\n      required\n      helperText="Uppercase alphanumeric"\n    />\n\n    <FormField\n      label="Email"\n      id="email"\n      name="email"\n      type="email"\n      bind:value={formData.email}\n    />\n\n    <Button type="submit">Submit</Button>\n  </form>\n</Card>\n```\n\n## Date Formatting\n\n```typescript\nimport { formatDate, formatDateTime, formatRelativeTime } from '$utils/date-format';\n\nconst date = new Date('2024-01-15T10:30:00');\n\nconsole.log(formatDate(date));\n// Output: "Jan 15, 2024"\n\nconsole.log(formatDateTime(date));\n// Output: "Jan 15, 2024, 10:30 AM"\n\nconsole.log(formatRelativeTime(date));\n// Output: "5 days ago" (depends on current date)\n```\n\n## Typical Workflow: Adding a New LPAR\n\n1. **Create LPAR with Basic Info**\n```typescript\nconst newLpar = {\n  name: 'Production LPAR 2',\n  code: 'PROD-LPAR-2',\n  customerId: 'customer-uuid',\n  description: 'Secondary production LPAR',\n  active: true\n};\n```\n\n2. **Assign Package to LPAR**\n```typescript\nlpar.currentPackageId = 'package-uuid';\n```\n\n3. **Generate Customer-Specific Deployment Plan**\n```typescript\nconst customerSoftwareNeeds = ['sw1', 'sw2', 'sw3'];\nconst plan = generateDeploymentPlan(\n  lpar,\n  targetPackage,\n  customerSoftwareNeeds\n);\n```\n\n4. **Install Software Based on Plan**\n```typescript\nfor (const item of plan.toInstall) {\n  lpar.softwareInstalled.push({\n    softwareId: item.softwareId,\n    version: item.version,\n    installedDate: new Date(),\n    rolledBack: false\n  });\n}\n```\n\n5. **Validate Compliance**\n```typescript\nconst validation = validateLparPackageCompliance(lpar, targetPackage);\nif (validation.compliant) {\n  console.log('LPAR is fully compliant with package');\n} else {\n  console.log('Missing:', validation.missingSoftware);\n  console.log('Outdated:', validation.outdatedSoftware);\n}\n```\n\n6. **Monitor Compatibility**\n```typescript\nconst score = calculateCompatibilityScore(lpar, targetPackage);\nif (score < 80) {\n  console.warn('LPAR compatibility is below threshold');\n}\n```\n\n## Error Handling Pattern\n\n```typescript\nimport { error } from '@sveltejs/kit';\n\nexport const load: PageServerLoad = async ({ params }) => {\n  const lpar = await db.lpar.findUnique({\n    where: { id: params.id }\n  });\n\n  if (!lpar) {\n    throw error(404, 'LPAR not found');\n  }\n\n  return { lpar };\n};\n```\n