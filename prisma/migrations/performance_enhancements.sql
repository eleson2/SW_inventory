-- Performance Enhancement Migration for SW Inventory\n-- Additional indexes and PostgreSQL functions\n\n-- ============================================================================\n-- ADDITIONAL INDEXES FOR PERFORMANCE\n-- ============================================================================\n\n-- Composite indexes for common query patterns\nCREATE INDEX IF NOT EXISTS idx_lpars_customer_package_active\n  ON lpars(customer_id, current_package_id, active)\n  WHERE active = true;\n\nCREATE INDEX IF NOT EXISTS idx_lpar_software_composite\n  ON lpar_software(lpar_id, software_id, rolled_back);\n\nCREATE INDEX IF NOT EXISTS idx_package_items_software_version\n  ON package_items(software_id, version, ptf_level);\n\n-- GIN index for JSONB columns (fast JSON queries)\nCREATE INDEX IF NOT EXISTS idx_software_version_history_gin\n  ON software USING GIN (version_history);\n\nCREATE INDEX IF NOT EXISTS idx_audit_log_changes_gin\n  ON audit_log USING GIN (changes);\n\n-- Full-text search indexes\nCREATE INDEX IF NOT EXISTS idx_customers_name_trgm\n  ON customers USING gin (name gin_trgm_ops);\n\nCREATE INDEX IF NOT EXISTS idx_software_name_trgm\n  ON software USING gin (name gin_trgm_ops);\n\n-- Partial indexes for common filters\nCREATE INDEX IF NOT EXISTS idx_software_active_vendor\n  ON software(vendor_id)\n  WHERE active = true;\n\nCREATE INDEX IF NOT EXISTS idx_packages_active_recent\n  ON packages(release_date DESC)\n  WHERE active = true;\n\n-- ============================================================================\n-- POSTGRESQL FUNCTIONS\n-- ============================================================================\n\n-- Function: Get LPAR compatibility score with a package\nCREATE OR REPLACE FUNCTION get_lpar_package_compatibility(\n  p_lpar_id UUID,\n  p_package_id UUID\n) RETURNS INTEGER AS $$\nDECLARE\n  total_items INTEGER;\n  compatible_items INTEGER;\nBEGIN\n  -- Count total required items in package\n  SELECT COUNT(*)\n  INTO total_items\n  FROM package_items\n  WHERE package_id = p_package_id;\n\n  IF total_items = 0 THEN\n    RETURN 100;\n  END IF;\n\n  -- Count compatible installed software\n  SELECT COUNT(*)\n  INTO compatible_items\n  FROM package_items pi\n  INNER JOIN lpar_software ls ON pi.software_id = ls.software_id\n  WHERE pi.package_id = p_package_id\n    AND ls.lpar_id = p_lpar_id\n    AND ls.current_version >= pi.version;\n\n  RETURN ROUND((compatible_items::NUMERIC / total_items::NUMERIC) * 100);\nEND;\n$$ LANGUAGE plpgsql IMMUTABLE;\n\n-- Function: Get software version history\nCREATE OR REPLACE FUNCTION get_software_versions(p_software_id UUID)\nRETURNS TABLE(version TEXT, ptf_level TEXT, released_at TIMESTAMP) AS $$\nBEGIN\n  RETURN QUERY\n  SELECT\n    (value->>'version')::TEXT as version,\n    (value->>'ptfLevel')::TEXT as ptf_level,\n    TO_TIMESTAMP((value->>'releasedAt')::TEXT, 'YYYY-MM-DD"T"HH24:MI:SS.MS"Z"') as released_at\n  FROM software,\n       jsonb_array_elements(version_history) as value\n  WHERE id = p_software_id\n  ORDER BY released_at DESC NULLS LAST;\nEND;\n$$ LANGUAGE plpgsql STABLE;\n\n-- Function: Clone software product\nCREATE OR REPLACE FUNCTION clone_software(\n  p_source_id UUID,\n  p_new_name TEXT,\n  p_new_code TEXT DEFAULT NULL\n) RETURNS UUID AS $$\nDECLARE\n  new_id UUID;\n  source_record RECORD;\nBEGIN\n  -- Get source software\n  SELECT * INTO source_record\n  FROM software\n  WHERE id = p_source_id;\n\n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'Source software not found';\n  END IF;\n\n  -- Insert cloned software\n  INSERT INTO software (\n    name,\n    vendor_id,\n    description,\n    current_version,\n    current_ptf_level,\n    version_history,\n    active,\n    created_at,\n    updated_at\n  )\n  VALUES (\n    p_new_name,\n    source_record.vendor_id,\n    'Cloned from: ' || source_record.name || COALESCE(E'\n\n' || source_record.description, ''),\n    source_record.current_version,\n    source_record.current_ptf_level,\n    source_record.version_history,\n    source_record.active,\n    NOW(),\n    NOW()\n  )\n  RETURNING id INTO new_id;\n\n  RETURN new_id;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Function: Clone package\nCREATE OR REPLACE FUNCTION clone_package(\n  p_source_id UUID,\n  p_new_name TEXT,\n  p_new_code TEXT,\n  p_new_version TEXT\n) RETURNS UUID AS $$\nDECLARE\n  new_package_id UUID;\n  source_record RECORD;\n  item_record RECORD;\nBEGIN\n  -- Get source package\n  SELECT * INTO source_record\n  FROM packages\n  WHERE id = p_source_id;\n\n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'Source package not found';\n  END IF;\n\n  -- Insert cloned package\n  INSERT INTO packages (\n    name,\n    code,\n    description,\n    version,\n    release_date,\n    active,\n    created_at,\n    updated_at\n  )\n  VALUES (\n    p_new_name,\n    p_new_code,\n    'Cloned from: ' || source_record.name || COALESCE(E'\n\n' || source_record.description, ''),\n    p_new_version,\n    NOW(),\n    source_record.active,\n    NOW(),\n    NOW()\n  )\n  RETURNING id INTO new_package_id;\n\n  -- Clone all package items\n  FOR item_record IN\n    SELECT * FROM package_items WHERE package_id = p_source_id\n  LOOP\n    INSERT INTO package_items (\n      package_id,\n      software_id,\n      version,\n      ptf_level,\n      required,\n      order_index,\n      created_at\n    )\n    VALUES (\n      new_package_id,\n      item_record.software_id,\n      item_record.version,\n      item_record.ptf_level,\n      item_record.required,\n      item_record.order_index,\n      NOW()\n    );\n  END LOOP;\n\n  RETURN new_package_id;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Function: Clone LPAR\nCREATE OR REPLACE FUNCTION clone_lpar(\n  p_source_id UUID,\n  p_new_name TEXT,\n  p_new_code TEXT,\n  p_customer_id UUID DEFAULT NULL\n) RETURNS UUID AS $$\nDECLARE\n  new_lpar_id UUID;\n  source_record RECORD;\n  sw_record RECORD;\n  target_customer_id UUID;\nBEGIN\n  -- Get source LPAR\n  SELECT * INTO source_record\n  FROM lpars\n  WHERE id = p_source_id;\n\n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'Source LPAR not found';\n  END IF;\n\n  -- Use provided customer_id or source customer_id\n  target_customer_id := COALESCE(p_customer_id, source_record.customer_id);\n\n  -- Insert cloned LPAR\n  INSERT INTO lpars (\n    name,\n    code,\n    customer_id,\n    description,\n    current_package_id,\n    active,\n    created_at,\n    updated_at\n  )\n  VALUES (\n    p_new_name,\n    p_new_code,\n    target_customer_id,\n    'Cloned from: ' || source_record.name || COALESCE(E'\n\n' || source_record.description, ''),\n    source_record.current_package_id,\n    source_record.active,\n    NOW(),\n    NOW()\n  )\n  RETURNING id INTO new_lpar_id;\n\n  -- Clone all installed software\n  FOR sw_record IN\n    SELECT * FROM lpar_software WHERE lpar_id = p_source_id\n  LOOP\n    INSERT INTO lpar_software (\n      lpar_id,\n      software_id,\n      current_version,\n      current_ptf_level,\n      previous_version,\n      previous_ptf_level,\n      installed_date,\n      rolled_back\n    )\n    VALUES (\n      new_lpar_id,\n      sw_record.software_id,\n      sw_record.current_version,\n      sw_record.current_ptf_level,\n      sw_record.previous_version,\n      sw_record.previous_ptf_level,\n      NOW(),\n      false  -- Reset rollback status\n    );\n  END LOOP;\n\n  RETURN new_lpar_id;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Function: Search across multiple entities\nCREATE OR REPLACE FUNCTION global_search(p_query TEXT, p_limit INTEGER DEFAULT 20)\nRETURNS TABLE(\n  entity_type TEXT,\n  entity_id UUID,\n  name TEXT,\n  code TEXT,\n  description TEXT,\n  rank REAL\n) AS $$\nBEGIN\n  RETURN QUERY\n  (\n    SELECT\n      'customer'::TEXT as entity_type,\n      c.id as entity_id,\n      c.name,\n      c.code,\n      c.description,\n      similarity(c.name, p_query) + similarity(COALESCE(c.code, ''), p_query) as rank\n    FROM customers c\n    WHERE c.name ILIKE '%' || p_query || '%'\n       OR c.code ILIKE '%' || p_query || '%'\n  )\n  UNION ALL\n  (\n    SELECT\n      'software'::TEXT,\n      s.id,\n      s.name,\n      NULL as code,\n      s.description,\n      similarity(s.name, p_query) as rank\n    FROM software s\n    WHERE s.name ILIKE '%' || p_query || '%'\n  )\n  UNION ALL\n  (\n    SELECT\n      'package'::TEXT,\n      p.id,\n      p.name,\n      p.code,\n      p.description,\n      similarity(p.name, p_query) + similarity(COALESCE(p.code, ''), p_query) as rank\n    FROM packages p\n    WHERE p.name ILIKE '%' || p_query || '%'\n       OR p.code ILIKE '%' || p_query || '%'\n  )\n  UNION ALL\n  (\n    SELECT\n      'lpar'::TEXT,\n      l.id,\n      l.name,\n      l.code,\n      l.description,\n      similarity(l.name, p_query) + similarity(COALESCE(l.code, ''), p_query) as rank\n    FROM lpars l\n    WHERE l.name ILIKE '%' || p_query || '%'\n       OR l.code ILIKE '%' || p_query || '%'\n  )\n  ORDER BY rank DESC\n  LIMIT p_limit;\nEND;\n$$ LANGUAGE plpgsql STABLE;\n\n-- ============================================================================\n-- ENABLE REQUIRED EXTENSIONS\n-- ============================================================================\n\n-- Enable pg_trgm for similarity searches\nCREATE EXTENSION IF NOT EXISTS pg_trgm;\n\n-- ============================================================================\n-- COMMENTS FOR DOCUMENTATION\n-- ============================================================================\n\nCOMMENT ON FUNCTION get_lpar_package_compatibility IS\n  'Calculate percentage compatibility between an LPAR and a package based on installed software versions';\n\nCOMMENT ON FUNCTION get_software_versions IS\n  'Extract and return version history from JSONB column in a structured format';\n\nCOMMENT ON FUNCTION clone_software IS\n  'Clone a software product with all its metadata, creating a new independent copy';\n\nCOMMENT ON FUNCTION clone_package IS\n  'Clone a package with all its items, creating a new version for deployment';\n\nCOMMENT ON FUNCTION clone_lpar IS\n  'Clone an LPAR with all its installed software, optionally to a different customer';\n\nCOMMENT ON FUNCTION global_search IS\n  'Search across customers, software, packages, and LPARs with relevance ranking';\n