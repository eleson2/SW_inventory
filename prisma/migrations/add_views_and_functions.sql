-- ============================================================================\n-- DATABASE VIEWS AND FUNCTIONS FOR SOFTWARE INVENTORY MANAGEMENT\n-- ============================================================================\n\n-- ----------------------------------------------------------------------------\n-- VIEW: software_with_current_version\n-- Purpose: Denormalized view of software with current version details\n-- Use Case: Displaying software lists without manual joins\n-- ----------------------------------------------------------------------------\nCREATE OR REPLACE VIEW software_with_current_version AS\nSELECT\n    s.id AS software_id,\n    s.name AS software_name,\n    s.vendor_id,\n    v.name AS vendor_name,\n    v.code AS vendor_code,\n    s.description,\n    s.active,\n    s.created_at,\n    s.updated_at,\n    sv.id AS current_version_id,\n    sv.version AS current_version,\n    sv.ptf_level AS current_ptf_level,\n    sv.release_date AS current_version_release_date,\n    sv.end_of_support AS current_version_end_of_support,\n    sv.release_notes AS current_version_notes,\n    -- Count of total versions for this software\n    (SELECT COUNT(*) FROM software_versions WHERE software_id = s.id) AS total_versions\nFROM software s\nLEFT JOIN software_versions sv ON s.current_version_id = sv.id\nLEFT JOIN vendors v ON s.vendor_id = v.id;\n\nCOMMENT ON VIEW software_with_current_version IS 'Denormalized view combining software with current version details and vendor info';\n\n-- ----------------------------------------------------------------------------\n-- VIEW: lpar_package_compliance\n-- Purpose: Check if LPARs have all required software from their assigned package\n-- Use Case: Compliance reporting, identifying out-of-sync LPARs\n-- ----------------------------------------------------------------------------\nCREATE OR REPLACE VIEW lpar_package_compliance AS\nWITH lpar_expected AS (\n    -- What software SHOULD be installed based on package assignment\n    SELECT\n        l.id AS lpar_id,\n        l.name AS lpar_name,\n        l.code AS lpar_code,\n        l.customer_id,\n        c.name AS customer_name,\n        p.id AS package_id,\n        p.name AS package_name,\n        p.version AS package_version,\n        pi.software_id,\n        s.name AS software_name,\n        sv.version AS expected_version,\n        sv.ptf_level AS expected_ptf_level,\n        pi.required,\n        pi.order_index\n    FROM lpars l\n    INNER JOIN customers c ON l.customer_id = c.id\n    LEFT JOIN packages p ON l.current_package_id = p.id\n    LEFT JOIN package_items pi ON p.id = pi.package_id\n    LEFT JOIN software s ON pi.software_id = s.id\n    LEFT JOIN software_versions sv ON pi.software_version_id = sv.id\n    WHERE l.active = true\n),\nlpar_actual AS (\n    -- What software IS actually installed\n    SELECT\n        ls.lpar_id,\n        ls.software_id,\n        ls.current_version,\n        ls.current_ptf_level,\n        ls.rolled_back,\n        ls.installed_date\n    FROM lpar_software ls\n)\nSELECT\n    le.lpar_id,\n    le.lpar_name,\n    le.lpar_code,\n    le.customer_id,\n    le.customer_name,\n    le.package_id,\n    le.package_name,\n    le.package_version,\n    le.software_id,\n    le.software_name,\n    le.expected_version,\n    le.expected_ptf_level,\n    le.required,\n    la.current_version AS installed_version,\n    la.current_ptf_level AS installed_ptf_level,\n    la.rolled_back,\n    la.installed_date,\n    -- Compliance flags\n    CASE\n        WHEN la.software_id IS NULL AND le.required = true THEN 'MISSING_REQUIRED'\n        WHEN la.software_id IS NULL AND le.required = false THEN 'MISSING_OPTIONAL'\n        WHEN la.current_version != le.expected_version THEN 'VERSION_MISMATCH'\n        WHEN la.current_ptf_level != le.expected_ptf_level THEN 'PTF_MISMATCH'\n        WHEN la.rolled_back = true THEN 'ROLLED_BACK'\n        ELSE 'COMPLIANT'\n    END AS compliance_status,\n    -- Priority for sorting\n    CASE\n        WHEN la.software_id IS NULL AND le.required = true THEN 1\n        WHEN la.rolled_back = true THEN 2\n        WHEN la.current_version != le.expected_version THEN 3\n        WHEN la.current_ptf_level != le.expected_ptf_level THEN 4\n        ELSE 5\n    END AS priority\nFROM lpar_expected le\nLEFT JOIN lpar_actual la ON le.lpar_id = la.lpar_id AND le.software_id = la.software_id;\n\nCOMMENT ON VIEW lpar_package_compliance IS 'Shows compliance status of each LPAR against its assigned package';\n\n-- ----------------------------------------------------------------------------\n-- VIEW: rollback_history\n-- Purpose: Comprehensive rollback history with context\n-- Use Case: Analyzing problem software, rollback frequency\n-- ----------------------------------------------------------------------------\nCREATE OR REPLACE VIEW rollback_history AS\nSELECT\n    ls.id AS lpar_software_id,\n    l.id AS lpar_id,\n    l.name AS lpar_name,\n    l.code AS lpar_code,\n    c.id AS customer_id,\n    c.name AS customer_name,\n    s.id AS software_id,\n    s.name AS software_name,\n    v.name AS vendor_name,\n    ls.current_version,\n    ls.current_ptf_level,\n    ls.previous_version,\n    ls.previous_ptf_level,\n    ls.rolled_back,\n    ls.rolled_back_at,\n    ls.rollback_reason,\n    ls.installed_date,\n    -- Time to rollback (how long before issues found)\n    EXTRACT(EPOCH FROM (ls.rolled_back_at - ls.installed_date)) / 3600 AS hours_until_rollback,\n    -- Days since rollback\n    EXTRACT(DAY FROM (NOW() - ls.rolled_back_at)) AS days_since_rollback\nFROM lpar_software ls\nINNER JOIN lpars l ON ls.lpar_id = l.id\nINNER JOIN customers c ON l.customer_id = c.id\nINNER JOIN software s ON ls.software_id = s.id\nINNER JOIN vendors v ON s.vendor_id = v.id\nWHERE ls.rolled_back = true\nORDER BY ls.rolled_back_at DESC;\n\nCOMMENT ON VIEW rollback_history IS 'Complete rollback history with timing analysis';\n\n-- ----------------------------------------------------------------------------\n-- VIEW: software_adoption_rate\n-- Purpose: Track which versions are deployed across LPARs\n-- Use Case: Understanding version adoption, planning upgrades\n-- ----------------------------------------------------------------------------\nCREATE OR REPLACE VIEW software_adoption_rate AS\nWITH version_usage AS (\n    SELECT\n        ls.software_id,\n        ls.current_version,\n        ls.current_ptf_level,\n        COUNT(DISTINCT ls.lpar_id) AS lpar_count,\n        COUNT(DISTINCT l.customer_id) AS customer_count,\n        SUM(CASE WHEN ls.rolled_back = true THEN 1 ELSE 0 END) AS rollback_count\n    FROM lpar_software ls\n    INNER JOIN lpars l ON ls.lpar_id = l.id\n    WHERE l.active = true\n    GROUP BY ls.software_id, ls.current_version, ls.current_ptf_level\n),\ntotal_lpars AS (\n    SELECT\n        s.id AS software_id,\n        COUNT(DISTINCT ls.lpar_id) AS total_lpar_count\n    FROM software s\n    LEFT JOIN lpar_software ls ON s.id = ls.software_id\n    INNER JOIN lpars l ON ls.lpar_id = l.id\n    WHERE l.active = true\n    GROUP BY s.id\n)\nSELECT\n    s.id AS software_id,\n    s.name AS software_name,\n    v.name AS vendor_name,\n    vu.current_version,\n    vu.current_ptf_level,\n    vu.lpar_count,\n    vu.customer_count,\n    vu.rollback_count,\n    tl.total_lpar_count,\n    ROUND(100.0 * vu.lpar_count / NULLIF(tl.total_lpar_count, 0), 2) AS adoption_percentage,\n    -- Is this the current version?\n    CASE WHEN sv.is_current = true THEN true ELSE false END AS is_current_version,\n    sv.release_date AS version_release_date,\n    -- Days since this version was released\n    EXTRACT(DAY FROM (NOW() - sv.release_date)) AS days_since_release\nFROM version_usage vu\nINNER JOIN software s ON vu.software_id = s.id\nINNER JOIN vendors v ON s.vendor_id = v.id\nLEFT JOIN total_lpars tl ON s.id = tl.software_id\nLEFT JOIN software_versions sv ON s.id = sv.software_id\n    AND vu.current_version = sv.version\n    AND (vu.current_ptf_level = sv.ptf_level OR (vu.current_ptf_level IS NULL AND sv.ptf_level IS NULL))\nORDER BY s.name, adoption_percentage DESC;\n\nCOMMENT ON VIEW software_adoption_rate IS 'Version adoption statistics across all LPARs';\n\n-- ----------------------------------------------------------------------------\n-- MATERIALIZED VIEW: lpar_dashboard\n-- Purpose: High-performance dashboard data (refresh periodically)\n-- Use Case: Dashboard UI, reporting\n-- ----------------------------------------------------------------------------\nCREATE MATERIALIZED VIEW lpar_dashboard AS\nSELECT\n    l.id AS lpar_id,\n    l.name AS lpar_name,\n    l.code AS lpar_code,\n    c.id AS customer_id,\n    c.name AS customer_name,\n    p.id AS package_id,\n    p.name AS package_name,\n    p.version AS package_version,\n    l.active,\n    l.updated_at AS last_updated,\n    -- Software counts\n    (SELECT COUNT(*) FROM lpar_software ls WHERE ls.lpar_id = l.id) AS software_count,\n    (SELECT COUNT(*) FROM lpar_software ls WHERE ls.lpar_id = l.id AND ls.rolled_back = true) AS rollback_count,\n    -- Compliance summary\n    (SELECT COUNT(*)\n     FROM lpar_package_compliance lpc\n     WHERE lpc.lpar_id = l.id\n       AND lpc.compliance_status = 'MISSING_REQUIRED') AS missing_required_count,\n    (SELECT COUNT(*)\n     FROM lpar_package_compliance lpc\n     WHERE lpc.lpar_id = l.id\n       AND lpc.compliance_status = 'VERSION_MISMATCH') AS version_mismatch_count,\n    (SELECT COUNT(*)\n     FROM lpar_package_compliance lpc\n     WHERE lpc.lpar_id = l.id\n       AND lpc.compliance_status = 'COMPLIANT') AS compliant_count,\n    -- Overall health score (0-100)\n    CASE\n        WHEN (SELECT COUNT(*) FROM lpar_software ls WHERE ls.lpar_id = l.id) = 0 THEN 0\n        ELSE ROUND(\n            100.0 * (\n                SELECT COUNT(*)\n                FROM lpar_package_compliance lpc\n                WHERE lpc.lpar_id = l.id AND lpc.compliance_status = 'COMPLIANT'\n            ) / NULLIF(\n                (SELECT COUNT(*) FROM lpar_package_compliance lpc WHERE lpc.lpar_id = l.id),\n                0\n            ),\n            2\n        )\n    END AS health_score,\n    -- Most recent install\n    (SELECT MAX(ls.installed_date) FROM lpar_software ls WHERE ls.lpar_id = l.id) AS last_install_date,\n    -- Most recent rollback\n    (SELECT MAX(ls.rolled_back_at) FROM lpar_software ls WHERE ls.lpar_id = l.id AND ls.rolled_back = true) AS last_rollback_date\nFROM lpars l\nINNER JOIN customers c ON l.customer_id = c.id\nLEFT JOIN packages p ON l.current_package_id = p.id\nWHERE l.active = true;\n\n-- Create index on materialized view for fast lookups\nCREATE UNIQUE INDEX idx_lpar_dashboard_lpar_id ON lpar_dashboard(lpar_id);\nCREATE INDEX idx_lpar_dashboard_customer_id ON lpar_dashboard(customer_id);\nCREATE INDEX idx_lpar_dashboard_health_score ON lpar_dashboard(health_score);\n\nCOMMENT ON MATERIALIZED VIEW lpar_dashboard IS 'Pre-computed dashboard metrics for LPARs (refresh with: REFRESH MATERIALIZED VIEW lpar_dashboard)';\n\n-- ----------------------------------------------------------------------------\n-- FUNCTION: get_version_upgrade_path\n-- Purpose: Find all versions between two versions for upgrade planning\n-- Parameters:\n--   p_software_id: UUID of software\n--   p_from_version: Starting version\n--   p_to_version: Target version\n-- Returns: Table of versions in chronological order\n-- ----------------------------------------------------------------------------\nCREATE OR REPLACE FUNCTION get_version_upgrade_path(\n    p_software_id UUID,\n    p_from_version VARCHAR(50),\n    p_to_version VARCHAR(50)\n)\nRETURNS TABLE (\n    version_id UUID,\n    version VARCHAR(50),\n    ptf_level VARCHAR(50),\n    release_date TIMESTAMP,\n    release_notes TEXT,\n    step_number INTEGER\n) AS $$\nBEGIN\n    RETURN QUERY\n    WITH version_path AS (\n        SELECT\n            sv.id,\n            sv.version,\n            sv.ptf_level,\n            sv.release_date,\n            sv.release_notes,\n            ROW_NUMBER() OVER (ORDER BY sv.release_date) AS step_num\n        FROM software_versions sv\n        WHERE sv.software_id = p_software_id\n          AND sv.release_date >= (\n              SELECT release_date FROM software_versions\n              WHERE software_id = p_software_id AND version = p_from_version\n              LIMIT 1\n          )\n          AND sv.release_date <= (\n              SELECT release_date FROM software_versions\n              WHERE software_id = p_software_id AND version = p_to_version\n              LIMIT 1\n          )\n        ORDER BY sv.release_date\n    )\n    SELECT\n        vp.id,\n        vp.version,\n        vp.ptf_level,\n        vp.release_date,\n        vp.release_notes,\n        vp.step_num::INTEGER\n    FROM version_path vp;\nEND;\n$$ LANGUAGE plpgsql STABLE;\n\nCOMMENT ON FUNCTION get_version_upgrade_path IS 'Returns ordered list of versions between two versions for upgrade planning';\n\n-- ----------------------------------------------------------------------------\n-- FUNCTION: check_package_deployment_impact\n-- Purpose: Simulate package deployment and show what would change\n-- Parameters:\n--   p_lpar_id: UUID of target LPAR\n--   p_package_id: UUID of package to deploy\n-- Returns: Table showing changes that would occur\n-- ----------------------------------------------------------------------------\nCREATE OR REPLACE FUNCTION check_package_deployment_impact(\n    p_lpar_id UUID,\n    p_package_id UUID\n)\nRETURNS TABLE (\n    software_id UUID,\n    software_name VARCHAR(100),\n    current_version VARCHAR(50),\n    current_ptf_level VARCHAR(50),\n    new_version VARCHAR(50),\n    new_ptf_level VARCHAR(50),\n    change_type VARCHAR(20),\n    required BOOLEAN\n) AS $$\nBEGIN\n    RETURN QUERY\n    WITH package_software AS (\n        -- Software in the new package\n        SELECT\n            pi.software_id,\n            s.name AS software_name,\n            sv.version AS pkg_version,\n            sv.ptf_level AS pkg_ptf_level,\n            pi.required\n        FROM package_items pi\n        INNER JOIN software s ON pi.software_id = s.id\n        INNER JOIN software_versions sv ON pi.software_version_id = sv.id\n        WHERE pi.package_id = p_package_id\n    ),\n    current_software AS (\n        -- Currently installed software\n        SELECT\n            ls.software_id,\n            ls.current_version,\n            ls.current_ptf_level\n        FROM lpar_software ls\n        WHERE ls.lpar_id = p_lpar_id\n    )\n    SELECT\n        COALESCE(ps.software_id, cs.software_id),\n        ps.software_name,\n        cs.current_version,\n        cs.current_ptf_level,\n        ps.pkg_version,\n        ps.pkg_ptf_level,\n        CASE\n            WHEN cs.software_id IS NULL THEN 'INSTALL'::VARCHAR(20)\n            WHEN ps.software_id IS NULL THEN 'REMOVE'::VARCHAR(20)\n            WHEN cs.current_version != ps.pkg_version OR\n                 COALESCE(cs.current_ptf_level, '') != COALESCE(ps.pkg_ptf_level, '')\n            THEN 'UPGRADE'::VARCHAR(20)\n            ELSE 'NO_CHANGE'::VARCHAR(20)\n        END,\n        ps.required\n    FROM package_software ps\n    FULL OUTER JOIN current_software cs ON ps.software_id = cs.software_id\n    WHERE ps.software_id IS NOT NULL OR cs.software_id IS NOT NULL\n    ORDER BY\n        CASE\n            WHEN cs.software_id IS NULL THEN 1\n            WHEN ps.software_id IS NULL THEN 3\n            ELSE 2\n        END,\n        ps.software_name;\nEND;\n$$ LANGUAGE plpgsql STABLE;\n\nCOMMENT ON FUNCTION check_package_deployment_impact IS 'Simulates package deployment showing what would change (install/upgrade/remove)';\n\n-- ----------------------------------------------------------------------------\n-- FUNCTION: get_software_problem_score\n-- Purpose: Calculate a "problem score" for software based on rollback history\n-- Parameters:\n--   p_software_id: UUID of software\n--   p_days_lookback: Number of days to analyze (default 90)\n-- Returns: Score from 0-100 (higher = more problems)\n-- ----------------------------------------------------------------------------\nCREATE OR REPLACE FUNCTION get_software_problem_score(\n    p_software_id UUID,\n    p_days_lookback INTEGER DEFAULT 90\n)\nRETURNS TABLE (\n    software_id UUID,\n    software_name VARCHAR(100),\n    total_installs INTEGER,\n    rollback_count INTEGER,\n    rollback_rate NUMERIC,\n    avg_hours_to_rollback NUMERIC,\n    problem_score INTEGER,\n    risk_level VARCHAR(20)\n) AS $$\nBEGIN\n    RETURN QUERY\n    WITH install_stats AS (\n        SELECT\n            COUNT(*) AS total,\n            SUM(CASE WHEN ls.rolled_back = true THEN 1 ELSE 0 END) AS rollbacks,\n            AVG(\n                CASE WHEN ls.rolled_back = true\n                THEN EXTRACT(EPOCH FROM (ls.rolled_back_at - ls.installed_date)) / 3600\n                ELSE NULL END\n            ) AS avg_hours\n        FROM lpar_software ls\n        WHERE ls.software_id = p_software_id\n          AND ls.installed_date >= NOW() - (p_days_lookback || ' days')::INTERVAL\n    )\n    SELECT\n        p_software_id,\n        s.name,\n        ist.total::INTEGER,\n        ist.rollbacks::INTEGER,\n        ROUND(100.0 * ist.rollbacks / NULLIF(ist.total, 0), 2),\n        ROUND(ist.avg_hours::NUMERIC, 2),\n        -- Problem score calculation (0-100)\n        LEAST(100, (\n            COALESCE(ROUND(100.0 * ist.rollbacks / NULLIF(ist.total, 0)), 0) * 0.7 + -- 70% weight on rollback rate\n            CASE\n                WHEN ist.avg_hours < 24 THEN 30  -- Critical if rolled back in <24 hours\n                WHEN ist.avg_hours < 72 THEN 20  -- High if rolled back in <72 hours\n                WHEN ist.avg_hours < 168 THEN 10 -- Medium if rolled back in <1 week\n                ELSE 0\n            END\n        ))::INTEGER,\n        -- Risk level\n        CASE\n            WHEN (100.0 * ist.rollbacks / NULLIF(ist.total, 0)) > 50 THEN 'CRITICAL'::VARCHAR(20)\n            WHEN (100.0 * ist.rollbacks / NULLIF(ist.total, 0)) > 25 THEN 'HIGH'::VARCHAR(20)\n            WHEN (100.0 * ist.rollbacks / NULLIF(ist.total, 0)) > 10 THEN 'MEDIUM'::VARCHAR(20)\n            WHEN ist.rollbacks > 0 THEN 'LOW'::VARCHAR(20)\n            ELSE 'STABLE'::VARCHAR(20)\n        END\n    FROM install_stats ist\n    CROSS JOIN software s\n    WHERE s.id = p_software_id;\nEND;\n$$ LANGUAGE plpgsql STABLE;\n\nCOMMENT ON FUNCTION get_software_problem_score IS 'Calculates problem score for software based on rollback frequency and timing';\n\n-- ----------------------------------------------------------------------------\n-- FUNCTION: refresh_dashboard\n-- Purpose: Helper to refresh the materialized view\n-- ----------------------------------------------------------------------------\nCREATE OR REPLACE FUNCTION refresh_dashboard()\nRETURNS VOID AS $$\nBEGIN\n    REFRESH MATERIALIZED VIEW CONCURRENTLY lpar_dashboard;\nEND;\n$$ LANGUAGE plpgsql;\n\nCOMMENT ON FUNCTION refresh_dashboard IS 'Refreshes the lpar_dashboard materialized view';\n\n-- ============================================================================\n-- USAGE EXAMPLES\n-- ============================================================================\n\n/*\n\n-- 1. Get all software with current versions\nSELECT * FROM software_with_current_version WHERE active = true;\n\n-- 2. Check LPAR compliance\nSELECT * FROM lpar_package_compliance WHERE compliance_status != 'COMPLIANT';\n\n-- 3. View rollback history\nSELECT * FROM rollback_history WHERE customer_name = 'Acme Corporation';\n\n-- 4. Check version adoption\nSELECT * FROM software_adoption_rate ORDER BY adoption_percentage DESC;\n\n-- 5. Dashboard metrics\nSELECT * FROM lpar_dashboard ORDER BY health_score ASC;\nREFRESH MATERIALIZED VIEW CONCURRENTLY lpar_dashboard; -- Refresh when needed\n\n-- 6. Plan upgrade path\nSELECT * FROM get_version_upgrade_path(\n    '<software_uuid>',\n    'V5R4M0',\n    'V5R6M0'\n);\n\n-- 7. Simulate package deployment\nSELECT * FROM check_package_deployment_impact(\n    '<lpar_uuid>',\n    '<package_uuid>'\n);\n\n-- 8. Get software problem scores\nSELECT * FROM get_software_problem_score('<software_uuid>', 90);\n\n-- Or for all software:\nSELECT s.id, ps.*\nFROM software s\nCROSS JOIN LATERAL get_software_problem_score(s.id, 90) ps\nORDER BY ps.problem_score DESC;\n\n*/\n